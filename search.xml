<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Error handling in go]]></title>
      <url>/2017/12/31/error-handling-in-go/</url>
      <content type="html"><![CDATA[<p>Most of the programming languages support multiple ways of handling errors, for example try-catching, value-checking, popping errors in the stack. Learning go I found the approach of this language is way different: you can let a function return an error (and eventual result(s)), thus not throwing any kind of error, and not returning “special values” like, for example, PHP’s <code>json_decode</code> (which can return <code>true</code>, <code>false</code>, <code>NULL</code>, <code>stdClass</code> or even an <code>array</code>!).</p>
<p>In this article I’ll describe what I found being (for me) the most elegant and convenient way of handling errors in Go.</p>
<a id="more"></a>
<p>As I previously stated, error generation and handling in Go is made in a way like this:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"errors"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">division</span><span class="params">(dividend <span class="keyword">int32</span>, divisor <span class="keyword">int32</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (divisor == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"Divisor is 0!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">float64</span>(dividend) / <span class="keyword">float64</span>(divisor), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  result, err := division(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(fmt.Sprintf(<span class="string">"%d/%d is not supported: %s"</span>, <span class="number">2</span>, <span class="number">0</span>, err))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(fmt.Sprintf(<span class="string">"%d/%d = %.2f"</span>, <span class="number">2</span>, <span class="number">0</span>, result))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: 2/0 is not supported: Divisor is 0!</span></span><br></pre></td></tr></table></figure>
<p>The explanation is pretty simple: check if the error is not nil, and if it is, panic or handle the error. Which is fine, unless you have to read and check a series of data.</p>
<p>I’ll reference myself in this by showing you a snippet of code of one mf my projects, <a href="https://github.com/elegos/nwn-toolset-go" target="_blank" rel="noopener">NWN Toolset go</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractHeader</span><span class="params">(file *os.File)</span> <span class="params">(Header, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> result = Header&#123;&#125;</span><br><span class="line"></span><br><span class="line">  bytes, err := fileReader.ReadAndCheck(file, <span class="number">4</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">  &#125;</span><br><span class="line">  result.FileType = strings.Trim(<span class="keyword">string</span>(bytes), <span class="string">"\x00"</span>)</span><br><span class="line"></span><br><span class="line">  bytes, err = fileReader.ReadAndCheck(file, <span class="number">4</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">  &#125;</span><br><span class="line">  result.Version = strings.Trim(<span class="keyword">string</span>(bytes), <span class="string">"\x00"</span>)</span><br><span class="line"></span><br><span class="line">  bytes, err = fileReader.ReadAndCheck(file, <span class="number">4</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">  &#125;</span><br><span class="line">  result.LanguageCount = fileReader.BytesToUint32LE(bytes)</span><br><span class="line"></span><br><span class="line">  bytes, err = fileReader.ReadAndCheck(file, <span class="number">4</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">  &#125;</span><br><span class="line">  result.LocalizedStringSize = fileReader.BytesToUint32LE(bytes)</span><br><span class="line"></span><br><span class="line">  bytes, err = fileReader.ReadAndCheck(file, <span class="number">4</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">  &#125;</span><br><span class="line">  result.EntryCount = fileReader.BytesToUint32LE(bytes)</span><br><span class="line">  <span class="comment">// continues for a series of reads...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And this is what I ended up with (magic explained later):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractHeader</span><span class="params">(file *os.File)</span> <span class="params">(Header, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> readerBag = fileReader.ByteReaderBag&#123;File: file&#125;</span><br><span class="line">  <span class="keyword">var</span> result = Header&#123;</span><br><span class="line">    FileType:                strings.Trim(fileReader.ReadStringFromBytes(&amp;readerBag, <span class="number">4</span>), <span class="string">"\x00"</span>),</span><br><span class="line">    Version:                 strings.Trim(fileReader.ReadStringFromBytes(&amp;readerBag, <span class="number">4</span>), <span class="string">"\x00"</span>),</span><br><span class="line">    LanguageCount:           fileReader.ReadUint32FromBytes(&amp;readerBag),</span><br><span class="line">    LocalizedStringSize:     fileReader.ReadUint32FromBytes(&amp;readerBag),</span><br><span class="line">    EntryCount:              fileReader.ReadUint32FromBytes(&amp;readerBag),</span><br><span class="line">    OffsetToLocalizedString: fileReader.ReadUint32FromBytes(&amp;readerBag),</span><br><span class="line">    OffsetToKeyList:         fileReader.ReadUint32FromBytes(&amp;readerBag),</span><br><span class="line">    OffsetToResourceList:    fileReader.ReadUint32FromBytes(&amp;readerBag),</span><br><span class="line">    BuildYear:               fileReader.ReadUint32FromBytes(&amp;readerBag),</span><br><span class="line">    BuildDay:                fileReader.ReadUint32FromBytes(&amp;readerBag),</span><br><span class="line">    DescriptionStrRef:       fileReader.ReadUint32FromBytes(&amp;readerBag),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> reservedBytes = fileReader.ReadBytes(&amp;readerBag, <span class="number">116</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">copy</span>(result.Reserved[:], reservedBytes)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result, readerBag.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I assure you this code is 100% equivalent to the previous one, and it’s all of it (i.e. I didn’t truncate it). Much simplier, isn’t it?</p>
<p>I’m not a genious and this is not all of my work. I took inspiration from this <a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">go’s blog post</a>. More or less it rightfully states that errors are not 2nd grade citizens and they should be always read and checked against nil, but keeping reading them make the code become ugly very soon (see the previous example!).</p>
<p>Here is explained the magic code, but first some definitions (strait from my project’s sources):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ByteReaderBag container used to gracefully manage file reading errors</span></span><br><span class="line"><span class="keyword">type</span> ByteReaderBag <span class="keyword">struct</span> &#123;</span><br><span class="line">  File *os.File</span><br><span class="line">  Err  error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadAndCheck reads the data from the file and check whether it has been read</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAndCheck</span><span class="params">(file *os.File, toRead <span class="keyword">uint32</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Not important for this example, it reads the data and checks for the bytes read</span></span><br><span class="line">  <span class="comment">// in case the read bytes are not the ones requested, it will return a valorised error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadBytes read toRead bytes and store any error in the bag</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadBytes</span><span class="params">(readerBag *ByteReaderBag, toRead <span class="keyword">uint32</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">  <span class="comment">// do not process if there is already a previous error in the bag</span></span><br><span class="line">  <span class="keyword">if</span> readerBag.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bytes, err := ReadAndCheck(readerBag.File, toRead)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// this will prevent future readings to proceed</span></span><br><span class="line">    readerBag.Err = err</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s first analyse what we previously did in the first, verbose example: a cycle of reads, checking at each iteration the error, and in case returning the value with the error (stopping the code from running). This is what we need to continue behaving like, if we want to keep the same functionality.</p>
<p><code>ByteReaderBag</code> is a struct which contains the reference of a file and an error. It is then passed by pointer to the reading function, which will, in few words, process the reading until an error occours, then it will stop processing, even if still allowing you to call it again and again without having to check the error. After all the calls to <code>ReadBytes</code> you can return or handle the error once, and the functionality will be preserved (stop to read in case of error and manage / return the error itself).</p>
<p>This has some implications:</p>
<ul>
<li>It’s way more readable</li>
<li>It will allow programmers to not hate the code (:D)</li>
<li>It will be way easier to test the code (and maximise the code coverage), having to test the error handling only in one function and not several times for each read/write/whatever. Please take a look at the tests of my project to have an idea (<a href="https://github.com/elegos/nwn-toolset-go/blob/master/src/aurora/file/erf/erf_test.go" target="_blank" rel="noopener">testing using the reading function</a> and <a href="https://github.com/elegos/nwn-toolset-go/blob/master/src/aurora/tools/fileReader/fileReader_test.go" target="_blank" rel="noopener">testing the error generation</a>).</li>
</ul>
<p>Cool, huh? :)</p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> error handling </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/31/hello-world/</url>
      <content type="html"><![CDATA[<p>It is tradition in the developers’ world to start off with a “Hello World” application.</p>
<p>This is mine :D</p>
<p>Sooooo… hello, world! This is the n-th declination of my website. I previously<br>wrote my website’s themes, using whatever implementation of “who knows” of a CMS.<br>I’ve now moved to Hexo, a minimalistic, static-generator blog / website application<br>written for node. So far, so great!</p>
<p>This blog will focus on the things I do in my profession and in my side-works (more to follow).</p>
<p>So… Keep calm and good retro style navigation!</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
